<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommonAPITests: Test List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CommonAPITests
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Test List </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Global <a class="el" href="AFExtended_8cpp.html#aebff976c36d632c971f5ea5c7448559d">AFExtended_Attributes</a>  ()</dt>
<dd><a class="anchor" id="_test000002"></a>Check that attributes work through extended interfaces  </dd>
<dt>Global <a class="el" href="AFExtended_8cpp.html#a4a5d4f92b917166f7ecc1a2ee7348c49">AFExtended_Broadcast</a>  ()</dt>
<dd><a class="anchor" id="_test000003"></a>Test broadcasts. Subscribe to a broadcast, and see that the value is correctly received.  </dd>
<dt>Global <a class="el" href="AFExtended_8cpp.html#a544e738d8ad4b45d5d3d16a9a4f71451">AFExtended_MethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000001"></a>Check that method calls work through extended interfaces  </dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#ab9b563f93b6614d0d40469e75f5261b4">AFManaged_AddRemoveManagedInterfaceMultiple</a>  ()</dt>
<dd><a class="anchor" id="_test000005"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Add a second instance of the same managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Remove all the managed interfaces from the manager</li>
<li>Check that the client is notified about the removed interfaces  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a5d6400bdbbf3ab4de9c8440f11465b7d">AFManaged_AddRemoveManagedInterfaceSingle</a>  ()</dt>
<dd><a class="anchor" id="_test000004"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Remove the managed interface from the manager</li>
<li>Check that the client is notified about the removed interface  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a1668e2a7eb4e44aef68d715e75ce7f3e">AFManaged_AddRemoveMultipleManagedInterfacesMultiple</a>  ()</dt>
<dd><a class="anchor" id="_test000007"></a><ul>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Add a different managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Add a second instance of the same managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Remove all the managed interfaces from the manager</li>
<li>Check that the client is notified about the removed interfaces  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a9212e31f6f6eb3703583d0bf5df89c7f">AFManaged_AddRemoveMultipleManagedInterfacesMultipleProxyNotActive</a>  ()</dt>
<dd><a class="anchor" id="_test000008"></a><ul>
<li></li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a3da59b3434030ecd12299664e01fd05c">AFManaged_AddRemoveMultipleManagedInterfacesSingle</a>  ()</dt>
<dd><a class="anchor" id="_test000006"></a><ul>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Add a different managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Remove all the managed interfaces from the manager</li>
<li>Check that the client is notified about the removed interfaces  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a820b2a24df0f6412d8cb8ce9106250cf">AFManaged_BuildProxyThroughManagerAndMethodCallMultipleDeregistrationExplicit</a>  ()</dt>
<dd><a class="anchor" id="_test000013"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add managed interfaces to the manager</li>
<li>Check that the client is notified about the newly added interfaces</li>
<li>Build proxies through the manager to the managed interfaces</li>
<li>Call a method on the managed interfaces and check call status</li>
<li>Explicitly deregister managed interfaces through their instance name  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#ad17f127e8fc2b05f59333bb1f77b217f">AFManaged_BuildProxyThroughManagerAndMethodCallMultipleDeregistrationExplicitAll</a>  ()</dt>
<dd><a class="anchor" id="_test000014"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add managed interfaces to the manager</li>
<li>Check that the client is notified about the newly added interfaces</li>
<li>Build proxies through the manager to the managed interfaces</li>
<li>Call a method on the managed interfaces and check call status</li>
<li>Deregister all managed interfaces through manager's stub adapter  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a155bdb2b00d60f96874d31092b548635">AFManaged_BuildProxyThroughManagerAndMethodCallMultipleDeregistrationImplicit</a>  ()</dt>
<dd><a class="anchor" id="_test000015"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add managed interfaces to the manager</li>
<li>Check that the client is notified about the newly added interfaces</li>
<li>Build proxies through the manager to the managed interfaces</li>
<li>Call a method on the managed interfaces and check call status</li>
<li>Don't deregister managed interfaces. This is done in dtor of manager's StubAdapterInternal when manager service is unregistered in TearDown() method.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#aa40a109576c06de4daf0c94d8895461d">AFManaged_BuildProxyThroughManagerAndMethodCallSingleDeregistrationExplicit</a>  ()</dt>
<dd><a class="anchor" id="_test000010"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Build a proxy through the manager to the managed device</li>
<li>Call a method on the managed device and check call status</li>
<li>Explicitly deregister managed interface through its instance name  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a017aed1dfde88f4e485c2e898e58342b">AFManaged_BuildProxyThroughManagerAndMethodCallSingleDeregistrationExplicitAll</a>  ()</dt>
<dd><a class="anchor" id="_test000011"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Build a proxy through the manager to the managed device</li>
<li>Call a method on the managed device and check call status</li>
<li>Deregister all managed interfaces through manager's stub adapter  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a0b5fcfd26730ab85150696ceb47505f1">AFManaged_BuildProxyThroughManagerAndMethodCallSingleDeregistrationImplicit</a>  ()</dt>
<dd><a class="anchor" id="_test000012"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Build a proxy through the manager to the managed device</li>
<li>Call a method on the managed device and check call status</li>
<li>Don't deregister managed interfaces. This is done in dtor of manager's StubAdapterInternal when manager service is unregistered in TearDown() method.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a79327942e5c4b9d8f621ed1964fd9a6c">AFManaged_BuildProxyThroughManagerInAvailabilityEventAndMethodCallInProxyStatusEventSingleDeregistrationExplicit</a>  ()</dt>
<dd><a class="anchor" id="_test000017"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Build a proxy through the manager to the managed device inside the availability event/callback</li>
<li>Subscribe to the proxy status event</li>
<li>Call a method on the managed device and check call status inside the proxy status event/callback (status == CommonAPI::AVAILABILITY_STATUS::AVAILABLE)</li>
<li>Remove and add the managed interface to the manager a few times</li>
<li>Explicitly deregister managed interface through its instance name  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#aa54c1ee9e89bb355fbf7725db8eb8e60">AFManaged_BuildProxyThroughManagerInAvailabilityEventAndMethodCallSingleDeregistrationExplicit</a>  ()</dt>
<dd><a class="anchor" id="_test000016"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Build a proxy through the manager to the managed device inside the availability event/callback</li>
<li>Call a method on the managed device and check call status inside the availability event/callback</li>
<li>Explicitly deregister managed interface through its instance name  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a706e5301efc37e68bc888101a0143630">AFManaged_CreateProxyToManagerInSameProcess</a>  ()</dt>
<dd><a class="anchor" id="_test000023"></a>Offer a interface manager and build two proxies to it. One proxy uses the same connection as the manager while the other uses a different connection. Check that both proxies get available and receive a available event  </dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a676a895e33c38cd61976e88b1b0cd0e5">AFManaged_DeleteManagerProxyInsideProxyStatusEventCallbackAndMethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000018"></a><ul>
<li>Subscribe to the proxy status event of the manager</li>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add the managed interfaces to the manager</li>
<li>Check that the client is notified about the newly added interfaces</li>
<li>Unregister manager service</li>
<li>Explicitly delete the proxy of the manager inside the proxy status event callback</li>
<li>Register manager service and build new proxy (Setup())</li>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Build a proxy through the manager to the managed device</li>
<li>Call a method on the managed device and check call status</li>
<li>TearDown()  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a4f5709ad3b9751a5ac5983226fd1b895">AFManaged_ProxyAddRemoveManagedInterfaceSingle</a>  ()</dt>
<dd><a class="anchor" id="_test000009"></a><ul>
<li>Subscribe on the events about availability status changes at the manager</li>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Remove the managed interface from the manager</li>
<li>Check that the client is notified about the removed interface  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a5dabbe494e11ac443fc15a69b168907b">AFManaged_ProxyManagerTestGetInstanceAvailabilityStatusAsync</a>  ()</dt>
<dd><a class="anchor" id="_test000022"></a><ul>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstances method to check that all registered instances are returned</li>
<li>Use the ProxyManager's checkInstanceAvailabilityStatusAsync method to check that all returned instances by getAvailableInstances are available</li>
<li>Add a different managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstances method to check that all registered instances are returned</li>
<li>Use the ProxyManager's checkInstanceAvailabilityStatusAsync method to check that all returned instances by getAvailableInstances are available</li>
<li>Add a second instance of the same managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstances method to check that all registered instances are returned</li>
<li>Use the ProxyManager's checkInstanceAvailabilityStatusAsync method to check that all returned instances by getAvailableInstances are available</li>
<li>Remove all the managed interfaces from the manager</li>
<li>Check that the client is notified about the removed interfaces  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#ac856591d8de58cc3815199ba9ce52596">AFManaged_ProxyManagerTestNonPrimitiveMethodsAsync</a>  ()</dt>
<dd><a class="anchor" id="_test000021"></a><ul>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstancesAsync method to check that all registered instances are returned</li>
<li>Add a different managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstancesAsync method to check that all registered instances are returned</li>
<li>Add a second instance of the same managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstancesAsync method to check that all registered instances are returned</li>
<li>Remove all the managed interfaces from the manager</li>
<li>Check that the client is notified about the removed interfaces  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a3f5d8a7ab823d7155bcc4b411dca43f8">AFManaged_ProxyManagerTestNonPrimitiveMethodsSync</a>  ()</dt>
<dd><a class="anchor" id="_test000020"></a><ul>
<li>Add a managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstances method to check that all registered instances are returned</li>
<li>Use the ProxyManager's checkInstanceAvailabilityStatus method to check that all returned instances by getAvailableInstances are available</li>
<li>Add a different managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstances method to check that all registered instances are returned</li>
<li>Use the ProxyManager's checkInstanceAvailabilityStatus method to check that all returned instances by getAvailableInstances are available</li>
<li>Add a second instance of the same managed interface to the manager</li>
<li>Check that the client is notified about the newly added interface</li>
<li>Use the ProxyManager's getAvailableInstances method to check that all registered instances are returned</li>
<li>Use the ProxyManager's checkInstanceAvailabilityStatus method to check that all returned instances by getAvailableInstances are available</li>
<li>Remove all the managed interfaces from the manager</li>
<li>Check that the client is notified about the removed interfaces  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFManaged_8cpp.html#a02b5320be90e8cd03d0dd7ba14d95788">AFManaged_ProxyManagerTestPrimitiveMethods</a>  ()</dt>
<dd><a class="anchor" id="_test000019"></a><ul>
<li>Test the getConnectionId, getDomain and getInteface methods available via the ProxyManager of the respective managed interfaces of the manager  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#a9002c494f0b4aeb4fc29dd90054b5a09">AFPolymorph_Broadcast</a>  ()</dt>
<dd><a class="anchor" id="_test000030"></a><ul>
<li>Call a method with a special value that tells the stub to send a broadcast signal</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#ad10c2b1a13362af286a8ea7f36c4fc65">AFPolymorph_MethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000029"></a><ul>
<li>Call a method whose input and output parameters are polymorphic structures</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#ae712e58fa76418ad997a2ea83bf338a3">AFPolymorph_SetAndGetAttributeDoublyUsedBaseStruct</a>  ()</dt>
<dd><a class="anchor" id="_test000031"></a><ul>
<li>Set and get an attribute through a polymorphic structure whose Base is also used by another identical structure.</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#a11a8736605b9d153d2ec05f71d63206d">AFPolymorph_SetAndGetAttributeEnum</a>  ()</dt>
<dd><a class="anchor" id="_test000025"></a><ul>
<li>Set and get a enum-type attribute through a polymorphic structure</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#a5b124697094ab0b6d7a2a872e5534129">AFPolymorph_SetAndGetAttributeString</a>  ()</dt>
<dd><a class="anchor" id="_test000027"></a><ul>
<li>Set and get a string-type attribute through a polymorphic structure</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#afca12a97a88a2338cd0e0362ae0c44d2">AFPolymorph_SetAndGetAttributeStruct</a>  ()</dt>
<dd><a class="anchor" id="_test000028"></a><ul>
<li>Set and get a struct-type attribute through a polymorphic structure</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#a86c84c41ab7c977bef77747f08e25b89">AFPolymorph_SetAndGetAttributeTypedef</a>  ()</dt>
<dd><a class="anchor" id="_test000024"></a><ul>
<li>Set and get a typedef-type attribute through a polymorphic structure</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFPolymorph_8cpp.html#aea6211d3b7fb992e853eeee50aa891cd">AFPolymorph_SetAndGetAttributeUInt</a>  ()</dt>
<dd><a class="anchor" id="_test000026"></a><ul>
<li>Set and get a uint-type attribute through a polymorphic structure</li>
<li>verify that the received data matches the transmitted data  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFSelective_8cpp.html#afb03c1574bae09b875ee3f1b42421fd8">AFSelective_ProxyBuildAndDestroy</a>  ()</dt>
<dd><p class="startdd"><a class="anchor" id="_test000035"></a>Test multiple selective broadcasts, with rejection.</p><ul>
<li>subscribe to stub three times: once from proxy2, once from proxy1 (accepted) once from proxy2 (rejected)</li>
<li>This should result with two subscription callbacks being called from broadcast. </li>
</ul>
<p class="enddd"><a class="anchor" id="_test000036"></a>Test Destruction of Proxies but service stay online There were an issue when a proxy which has nevery subscribed gets destructed with SomeIP binding (GLIPCI-1081). Therefore i added this test case.  </p>
</dd>
<dt>Global <a class="el" href="AFSelective_8cpp.html#a934e1b83b8dca7d249a0af6fcc435291">AFSelective_SelectiveBroadcast</a>  ()</dt>
<dd><a class="anchor" id="_test000033"></a>Test selective broadcasts.<ul>
<li>inform stub to start accepting subscriptions</li>
<li>subscribe to the selective broadcast</li>
<li>check that no error was received (in a reasonable time)</li>
<li>inform stub to send a broadcast</li>
<li>check that a correct value is received  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFSelective_8cpp.html#ababf8f1ffb3ae02e9ae3df20b4487e68">AFSelective_SelectiveBroadcastRejected</a>  ()</dt>
<dd><a class="anchor" id="_test000032"></a>Test selective broadcasts.<ul>
<li>inform stub to stop accepting subscriptions</li>
<li>try to subscribe to the selective broadcast</li>
<li>check that an error was received</li>
<li>inform stub to send a broadcast</li>
<li>check that nothing was received in a reasonable time  </li>
</ul>
</dd>
<dt>Global <a class="el" href="AFSelective_8cpp.html#a3b1724dc303869021a9f77f7011677f7">AFSelective_SelectiveMultiBroadcast</a>  ()</dt>
<dd><a class="anchor" id="_test000034"></a>Test multiple selective broadcasts.<ul>
<li>inform stub to start accepting subscriptions</li>
<li>subscribe to the selective broadcast</li>
<li>check that no error was received (in a reasonable time)</li>
<li>inform stub to send a broadcast</li>
<li>check that a correct value is received  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributes_8cpp.html#ac1e1e8777410ce2c9e78b343c3203fa4">CMAttributes_AttributeGetAsynchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000038"></a>Test asynchronous getValue API function for attributes with combinations of additional properties readonly and noSubscriptions (testAttribute, testA readonly, testB noSubscriptions, testC readonly noSubscriptions).<ul>
<li>Set attribute to certain value on stub side.</li>
<li>Call getValue.</li>
<li>Check if returned call status is CommonAPI::CallStatus::SUCCESS.</li>
<li>Check if value of is equal to expected value.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributes_8cpp.html#ab2923338a2a3d6a64d1aaace0be8669e">CMAttributes_AttributeGetSynchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000037"></a>Test synchronous getValue API function for attributes with combinations of additional properties readonly and noSubscriptions (testAttribute, testA readonly, testB noSubscriptions, testC readonly noSubscriptions).<ul>
<li>Set attribute to certain value on stub side.</li>
<li>Call getValue.</li>
<li>Check if returned call status is CommonAPI::CallStatus::SUCCESS.</li>
<li>Check if value of is equal to expected value.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributes_8cpp.html#aaa9637da8321c39168ddd9d4f24d76c5">CMAttributes_AttributeSetAsynchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000040"></a>Test asynchronous setValue API function for attributes with combinations of additional properties readonly and noSubscriptions (testAttribute, testB noSubscriptions).<ul>
<li>Set attribute to certain value on proxy side.</li>
<li>Check if returned call status is CommonAPI::CallStatus::SUCCESS.</li>
<li>Check if returned value of setValue is equal to expected value.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributes_8cpp.html#a6a9a4b199b5f53cca69be373d4023295">CMAttributes_AttributeSetSynchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000039"></a>Test synchronous setValue API function for attributes with combinations of additional properties readonly and noSubscriptions (testAttribute, testB noSubscriptions)<ul>
<li>Set attribute to certain value on proxy side.</li>
<li>Check if returned call status is CommonAPI::CallStatus::SUCCESS.</li>
<li>Check if returned value of setValue is equal to expected value.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributes_8cpp.html#af0bae8775c88f573b4c6a40017e6da0f">CMAttributes_AttributeSubscription</a>  ()</dt>
<dd><a class="anchor" id="_test000041"></a>Test subscription API function for attributes </dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#aa78372df27699b940e37e4d46324d523">CMAttributeSubscription_DISABLED_SubscribeAndUnsubscribeImplicitWithCreatingNewProxyWithReassigning</a>  ()</dt>
<dd><a class="anchor" id="_test000049"></a>Test of subscribing and unsubscribing implicit with creating a new proxy with reassigning<ul>
<li>subscribe first callback</li>
<li>subscribe second callback</li>
<li>change value</li>
<li>check that both callbacks were executed by changing the value</li>
<li>create new proxy with reassigning. So the connection won't be destroyed and the callbacks are unsubscribed implicitly.</li>
<li>subscribe second callback</li>
<li>change value</li>
<li>check that only second callback was executed</li>
<li>unsubscribe second callback</li>
<li>change value</li>
<li>check that both callbacks were not executed by changing the value  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#ab0490b09fdaed92e0f9e4004decb2d43">CMAttributeSubscription_SubscribeAndUnsubscribeAndReSubscribe</a>  ()</dt>
<dd><a class="anchor" id="_test000057"></a>Test of behaviour in case subscribe, unsubscribe and resubscribe is done<ul>
<li>set default value</li>
<li>register service</li>
<li>subscribe for the attribute</li>
<li>current value must be communicated to the proxy</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxy</li>
<li>proxy unsubscribes for the attribute</li>
<li>value of attribute is not changed</li>
<li>value received by proxy is reset to 0</li>
<li>proxy resubscribes for the atribute</li>
<li>current value must be communicated to the proxy</li>
<li>value received must be equal to value received before last unsubscribe call</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a2870a6a4cdc93fcdbd1b20a6f87fd54b">CMAttributeSubscription_SubscribeAndUnsubscribeSequentially</a>  ()</dt>
<dd><p class="startdd"><a class="anchor" id="_test000047"></a>Test of subscribing and immediately unsubscribing a callback</p><ul>
<li>subscribe first callback</li>
<li>subscribe second callback</li>
<li>unsubscribe second callback</li>
<li>change value</li>
<li>check that only first callback was executed </li>
</ul>
<p class="enddd"><a class="anchor" id="_test000048"></a>Test of subscribing and unsubscribing sequentially</p><ul>
<li>subscribe first callback</li>
<li>subscribe second callback</li>
<li>change value</li>
<li>check that both callbacks were executed by changing the value</li>
<li>unsubscribe first callback</li>
<li>change value</li>
<li>check that only second callback was executed</li>
<li>unsubscribe second callback</li>
<li>change value</li>
<li>check that both callbacks were not executed by changing the value  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a57823aba7acbc178a93f81b0233bf36c">CMAttributeSubscription_SubscribeAndUnsubscribeTwoCallbacksCoexistent</a>  ()</dt>
<dd><a class="anchor" id="_test000046"></a>Test of subscribe and unsubscribe with two coexistent callbacks<ul>
<li>subscribe both callbacks</li>
<li>change value</li>
<li>check that both callbacks were executed by changing the value</li>
<li>unsubscribe both callbacks</li>
<li>change value</li>
<li>check that both callbacks were not executed by changing the value  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#ae04fed1665b94f3c1a95ce2a51e13edc">CMAttributeSubscription_SubscribeAndUnsubscribeUnsubscribe</a>  ()</dt>
<dd><a class="anchor" id="_test000050"></a>Test of behaviour in case unsubscribe is called two times<ul>
<li>set default value</li>
<li>register service</li>
<li>subscribe for the attribute</li>
<li>current value must be communicated to the proxy</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxy</li>
<li>proxy unsubscribes for the attribute</li>
<li>value of attribute is changed</li>
<li>changed value must not be communicated to the proxy</li>
<li>proxy unsubscribes again for the attribute</li>
<li>value of attribute is changed</li>
<li>changed value must not be communicated to the proxy</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#ac60f414bc5f98b689ddb939f4b1e9f24">CMAttributeSubscription_SubscribeMultipleProxysUnsubscribeAllResubscribe</a>  ()</dt>
<dd><a class="anchor" id="_test000058"></a>Test of behaviour in case subscribe and unsubscribe is done for multiple proxys on the same attribute and afterwards all proxys resubscribe<ul>
<li>set default value</li>
<li>register service</li>
<li>subscribe for the attribute with proxyA</li>
<li>subscribe for the attribute with proxyB</li>
<li>current value must be communicated to the proxyA</li>
<li>current value must be communicated to the proxyB</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxyA</li>
<li>changed value must be communicated to the proxyB</li>
<li>proxyA and proxy B unsubscribe for the attribute</li>
<li>value of attribute is not changed</li>
<li>value received is reset to 0</li>
<li>proxyA and proxyB resubscribe for the attribute</li>
<li>current value must be communicated to the proxy as initial value</li>
<li>value received must be equal to value received before last unsubscribe call</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#acc357945c728604ad3470e9050d5eab1">CMAttributeSubscription_SubscribeMultipleProxysUnsubscribeAllResubscribeSameEventgroup</a>  ()</dt>
<dd><a class="anchor" id="_test000059"></a>Test of behaviour in case subscribe and unsubscribe is done for multiple proxys on attributes in the same eventgroup and afterwards all proxys resubscribe<ul>
<li>set default value</li>
<li>register service</li>
<li>subscribe for the attribute 1 with proxyA</li>
<li>subscribe for the attribute 2 with proxyB</li>
<li>current value must be communicated to the proxyA</li>
<li>current value must be communicated to the proxyB</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxyA</li>
<li>changed value must be communicated to the proxyB</li>
<li>proxyA and proxy B unsubscribe for the attributes</li>
<li>value of attributes is not changed</li>
<li>value received is reset to 0</li>
<li>proxyA and proxyB resubscribe for the attribute 1 and 2</li>
<li>current value must be communicated to the proxys as initial value</li>
<li>value received must be equal to value received before last unsubscribe call</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a8164a963e248a1e4f137e63161fe5a0e">CMAttributeSubscription_SubscribeMultipleProxysUnsubscribeOneResubscribeSameEventgroup</a>  ()</dt>
<dd><a class="anchor" id="_test000060"></a>Test of behaviour in case two proxys A and B subscribe to events that are in one eventgroup, proxyB unsubscribes, and proxy A is still expected to receive changed values.<ul>
<li>set default value</li>
<li>register service</li>
<li>subscribe for the attribute with proxyA</li>
<li>subscribe for the attribute with proxyB</li>
<li>current value must be communicated to the proxyA</li>
<li>current value must be communicated to the proxyB</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxyA</li>
<li>changed value must be communicated to the proxyB</li>
<li>proxyB unsubscribes for the attribute</li>
<li>value of attribute is changed</li>
<li>value received must be equal to changed value for proxy A</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#ac8ebb860bf4d03b9602ea5e4978077c7">CMAttributeSubscription_SubscribeSecondProxyLater</a>  ()</dt>
<dd><a class="anchor" id="_test000054"></a>Test of subscribing a second proxy a little bit later<ul>
<li>proxy subscribes for an attribute of the service</li>
<li>register service</li>
<li>initial value must be communicated to the proxy</li>
<li>create a second proxy</li>
<li>second proxy subscribes for the same attribute of the service</li>
<li>current attribute value must be communicated to the proxy</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to both proxies</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a8c924b97bd48e8cf0368052b2825ecef">CMAttributeSubscription_SubscribeServiceNotAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000051"></a>Test of subscribing in case that service is not available<ul>
<li>set default value</li>
<li>subscribe for the attribute</li>
<li>no value is communicated to the proxy</li>
<li>register service</li>
<li>current value must be communicated to the proxy</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxy</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a4c2d6d6fe3c00730225b757e2e08996d">CMAttributeSubscription_SubscribeThreeCallbacksServiceAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000056"></a>Test of subscribing three callbacks after registering the service<ul>
<li>register service</li>
<li>proxy subscribes three callbacks for an attribute of the service</li>
<li>initial value must be communicated to every callback  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a1dc6f1d01e64ccaeb93bdd3b18f3c66f">CMAttributeSubscription_SubscribeThreeCallbacksServiceNotAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000055"></a>Test of subscribing three callbacks before registering the service<ul>
<li>proxy subscribes three callbacks for an attribute of the service</li>
<li>register service</li>
<li>initial value must be communicated to every callback  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a791021929214425092657ebfea52ca68">CMAttributeSubscription_SubscribeUnregisterNoValueSetRegisterService</a>  ()</dt>
<dd><a class="anchor" id="_test000053"></a>Test of unregister a service in case a proxy is subscribed for an attribute of this service. During the unregistered time of the service the value of the attribute is not changed.<ul>
<li>register service</li>
<li>proxy subscribes for an attribute of the service</li>
<li>value of attribute is set</li>
<li>changed value must be communicated to the proxy</li>
<li>unregister service</li>
<li>register service</li>
<li>current attribute value must be communicated to the proxy</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxy</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#aa38112634e8d44e96bdefc128c6d7a42">CMAttributeSubscription_SubscribeUnregisterSetValueRegisterService</a>  ()</dt>
<dd><a class="anchor" id="_test000052"></a>Test of unregister a service in case a proxy is subscribed for an attribute of this service. During the unregistered time of the service the value of the attribute is changed.<ul>
<li>register service</li>
<li>proxy subscribes for an attribute of the service</li>
<li>value of attribute is set</li>
<li>changed value must be communicated to the proxy</li>
<li>unregister service</li>
<li>value of attribute is changed</li>
<li>changed value must not be communicated to the proxy</li>
<li>register service</li>
<li>current attribute value must be communicated to the proxy</li>
<li>value of attribute is changed</li>
<li>changed value must be communicated to the proxy</li>
<li>unregister service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a29f7dca7ff7b159317078f0b516457a1">CMAttributeSubscription_SubscriptionMultithreading</a>  ()</dt>
<dd><a class="anchor" id="_test000044"></a>Subscription test with several threads.<ul>
<li>Start several threads.</li>
<li>The threads subscribe for the availability status.</li>
<li>The available-callback subscribes for TestAttribute if service is available for proxy and</li>
<li>unsubscribes if service is not available for proxy.</li>
<li>Change attribute in service by set method; the new attribute value should be received by all the threads.</li>
<li>The new value is written into a queue.</li>
<li>Check if the values of each thread are written into the queue.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#af1044848dc4059793bceb97c81a32c4c">CMAttributeSubscription_SubscriptionOnAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000043"></a>Subscription test with subscription on available-event.<ul>
<li>Subscribe for available-event.</li>
<li>Available-callback subscribes for TestPredefinedTypeAttribute if service is available for proxy and unsubscribes if service is not available for proxy.</li>
<li>Change attribute in service by set method; the new attribute value should be received by the proxy because the service is not registered.</li>
<li>Register service and change value again; the value should now be received.</li>
<li>Unregister and change value again.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#a7f496169f87504715247e03e9398f375">CMAttributeSubscription_SubscriptionStandard</a>  ()</dt>
<dd><a class="anchor" id="_test000042"></a>Subscription standard test.<ul>
<li>Register service and check if proxy is available.</li>
<li>Proxy subscribes for TestAttribute (uint8_t).</li>
<li>Change attribute in service several times by set method.</li>
<li>Callback function in proxy writes the received values in a queue.</li>
<li>Check if values in the queue are the same as the values that were set in the service.</li>
<li>Unregister test service.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMAttributeSubscription_8cpp.html#ae9ff166a510c13370820ea5b3bcf1199">CMAttributeSubscription_SubscriptionUnsubscribeFromCallback</a>  ()</dt>
<dd><a class="anchor" id="_test000045"></a>Subscription test : unsibscribe from the subscription callback.<ul>
<li>Register service and check if proxy is available.</li>
<li>Proxy subscribes for TestAttribute (uint8_t).</li>
<li>Change attribute in service by set method.</li>
<li>Check if callback function in proxy received the right value.</li>
<li>Change value to the magic value 99: this triggers the callback to unsubscribe.</li>
<li>Change value again; the callback should now be called anymore.</li>
<li>Unregister the test service.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMBlockingCalls_8cpp.html#a3435985473b597fe80f9b8774c30f876">CMBlockingCalls_BlockInAvailabilityHandler</a>  ()</dt>
<dd><a class="anchor" id="_test000063"></a>Register availability handler which blocks and (de)register the corresponding service multiple times. After the serice stays available do a method call and check that the answer is received  </dd>
<dt>Global <a class="el" href="CMBlockingCalls_8cpp.html#aefa41e37a7e80d517da9074a7ce025f0">CMBlockingCalls_BlockInAvailabilityHandlerAndReceiveCallbacks</a>  ()</dt>
<dd><a class="anchor" id="_test000064"></a>Create proxy to service and wait until it is reported as available via a registered availability handler. As soon as it is available start sending requests to the service and wait for its replies. Check that the replies for this requests are dispatched even if the availablity handler for this service is blocked. This is tested through blocking in the availability handler after the main thread was notified about the the services' availability  </dd>
<dt>Global <a class="el" href="CMBlockingCalls_8cpp.html#a780943479d24e6d905d13f8a6ce7a5e4">CMBlockingCalls_BlockInProxyCallback</a>  ()</dt>
<dd><a class="anchor" id="_test000062"></a>Call test method and block in registered callback when processing responses. Check that all responses are delivered.  </dd>
<dt>Global <a class="el" href="CMBlockingCalls_8cpp.html#a7e125cddec556a4e8c58ced0106e7dbc">CMBlockingCalls_BlockInStubMethod</a>  ()</dt>
<dd><a class="anchor" id="_test000061"></a>Call test method which generates blocking calls on stub side and check if answers are received.  </dd>
<dt>Global <a class="el" href="CMBlockingCalls_8cpp.html#a8931f82907b5f35937e1ff4d2745701e">CMBlockingCalls_NestedBlockInStubMethods</a>  ()</dt>
<dd><a class="anchor" id="_test000065"></a>Call test method which generates blocking calls on stub. Ensure working dispatching even if main dispatch thread still blocked after a dispatch thread was spawned and joined again because another dispatch thread returned from the usercode in the meanwhile.  </dd>
<dt>Global <a class="el" href="CMBroadcasts_8cpp.html#aa3eee6385d8c63499ca23c070c7de2e3">CMBroadcasts_BroadcastStubGoesOfflineOnlineAgain</a>  ()</dt>
<dd><a class="anchor" id="_test000069"></a>Test BroadcastStubGoesOfflineOnlineAgain.<ul>
<li>service offline</li>
<li>subscribe to broadcast</li>
<li>service online</li>
<li>fire broadcast -&gt; proxy should receive</li>
<li>service offline</li>
<li>service online</li>
<li>fire again -&gt; proxy should receive again  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMBroadcasts_8cpp.html#a1935b58a9f5b57b267de82a0a4bb44a1">CMBroadcasts_NormalBroadcast</a>  ()</dt>
<dd><a class="anchor" id="_test000066"></a>Test broadcasts. Subscribe to a broadcast, and see that the value is correctly received.  </dd>
<dt>Global <a class="el" href="CMBroadcasts_8cpp.html#a01bbbc6a0418be2fade8416cc0a18653">CMBroadcasts_SelectiveBroadcast</a>  ()</dt>
<dd><a class="anchor" id="_test000068"></a>Test selective broadcasts.<ul>
<li>inform stub to start accepting subscriptions</li>
<li>subscribe to the selective broadcast</li>
<li>check that no error was received (in a reasonable time)</li>
<li>inform stub to send a broadcast</li>
<li>check that a correct value is received  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMBroadcasts_8cpp.html#a7befbb1bc46b1137a3a61795dee95be3">CMBroadcasts_SelectiveBroadcastRejected</a>  ()</dt>
<dd><a class="anchor" id="_test000067"></a>Test selective broadcasts.<ul>
<li>inform stub to stop accepting subscriptions</li>
<li>try to subscribe to the selective broadcast</li>
<li>check that an error was received</li>
<li>inform stub to send a broadcast</li>
<li>check that nothing was received in a reasonable time  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMBroadcasts_8cpp.html#aa753823aa8b89cc9519bf95d051023dd">CMBroadcasts_SelectiveBroadcastStubGoesOfflineOnlineAgain</a>  ()</dt>
<dd><a class="anchor" id="_test000070"></a>Test SelectiveBroadcastStubGoesOfflineOnlineAgain.<ul>
<li>service offline</li>
<li>subscribe to selective broadcast</li>
<li>service online</li>
<li>fire selective broadcast -&gt; proxy should receive</li>
<li>service offline</li>
<li>service online</li>
<li>fire again -&gt; proxy should receive again  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#aadf55f15809b5a00fe77bd0d2b0fb284">CMMethodCalls_AsynchronousMethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000073"></a>Call test method asynchronous and check call status.<ul>
<li>Test stub sets in-value of test method.</li>
<li>Make asynchronous call of test method.</li>
<li>Do checks of call status (CommonAPI::CallStatus::SUCCESS) and stored value in callback function.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#af95da0d4d9a9eecf0bc5781efbf83003">CMMethodCalls_AsynchronousMethodCallProxyBecomesAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000079"></a>Call test method asynchronous when proxy is not available. Proxy becomes available during call.<ul>
<li>Unregiser service</li>
<li>Wait that proxy is not available.</li>
<li>Test stub sets in-value of test method.</li>
<li>Set timeout of asynchronous call.</li>
<li>Make asynchronous call of test method.</li>
<li>Proxy becomes available during call.</li>
<li>Do checks of call status (CommonAPI::CallStatus::SUCCESS) and stored value in callback function.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a0f7ba9fe0f425dc6bd1ac5c76ac3b0b4">CMMethodCalls_AsynchronousMethodCallProxyNotAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000077"></a>Call test method asynchronous when proxy is not available.<ul>
<li>Unregister service.</li>
<li>Wait that proxy is not available.</li>
<li>Test stub sets in-value of test method.</li>
<li>Set timeout of asynchronous call.</li>
<li>Make asynchronous call of test method.</li>
<li>Do checks of call status (CommonAPI::CallStatus::NOT_AVAILABLE) and that timeout occurred.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a9ff9f43c6f5e419b98afd0a9e5b41011">CMMethodCalls_AsynchronousMethodCallProxyNotAvailableDeleteProxy</a>  ()</dt>
<dd><a class="anchor" id="_test000082"></a>Call test method asynchronous when proxy is not available and delete proxy.<ul>
<li>Unregister service.</li>
<li>Wait that proxy is not available.</li>
<li>Test stub sets in-value of test method.</li>
<li>Set timeout of asynchronous call.</li>
<li>Make asynchronous call of test method.</li>
<li>Start thread which deletes the proxy.</li>
<li>Check if proxy could be deleted.</li>
<li>Join created thread.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a070931c4395a9a47ced1b2526ba2dbc7">CMMethodCalls_AsynchronousMethodCallsProxyBecomesAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000081"></a>Call test method asynchronous multiple times when proxy is not available. Proxy becomes available during call<ul>
<li>Unregiser service</li>
<li>Wait that proxy is not available</li>
<li>Test stub set in-value of test methods.</li>
<li>Set timeouts of asynchronous calls (timeouts that are reached and timeouts that are not reached).</li>
<li>Make asynchronous calls of test method (2 expected timeouts, 3 successful calls).</li>
<li>Proxy becomes available during call</li>
<li>Do checks of call status (CommonAPI::CallStatus::SUCCESS and CommonAPI::CallStatus::NOT_AVAILABLE for expected timeouts), stored values and timeouts that occurred in callback functions.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#af55994c2c3a1ba8ec020e71b8f21d120">CMMethodCalls_AsynchronousMethodCallsReceiveNotAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000083"></a>Call test method via two proxies multiple times asynchronously while the service is unavailable and check if the provided callback is called with an error for every method call done.  </dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a7f1314ce2be7fbf1879436023a073bfd">CMMethodCalls_FireAndForget</a>  ()</dt>
<dd><a class="anchor" id="_test000072"></a>Call fire and forget method and check via broadcast that value was received.<ul>
<li>Subscribe to broadcast</li>
<li>Check that broadcast subscription succeeded</li>
<li>Make fire and forget method call</li>
<li>Check via broadcast that value was correctly reveived (Stub fires broadcast when value was received.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#ae5465e2d2ccb38e9639f81b62df1d296">CMMethodCalls_NestedAsynchronousMethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000075"></a>Call test method asynchronous and call test method asynchronous in callback (nested).<ul>
<li>Test stub sets in-values of test methods.</li>
<li>Make asynchronous call of test method.</li>
<li>Make asynchronous call of test method in callback (nested).</li>
<li>Do checks of call status (CommonAPI::CallStatus::SUCCESS) and stored values in callback functions.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a47b4f5bf023b36ec7a4ee97bbac93d6d">CMMethodCalls_NestedAsynchronousMethodCallProxyBecomesAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000080"></a>Call test method asynchronous and call test method asynchronous in callback (nested) when proxy is not available. Proxy becomes available during call.<ul>
<li>Unregiser service</li>
<li>Wait that proxy is not available.</li>
<li>Test stub sets in-values of test methods.</li>
<li>Set timeout of asynchronous calls.</li>
<li>Make asynchronous call of test method.</li>
<li>Make asynchronous call of test method in callback (nested).</li>
<li>Proxy becomes available during first async call.</li>
<li>Do checks of call status (CommonAPI::CallStatus::SUCCESS) and stored value in callback functions.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a7cc5a750a919f8a5011f6f6ca117381c">CMMethodCalls_NestedAsynchronousMethodCallProxyNotAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000078"></a>Call test method asynchronous and call test method asynchronous in callback (nested) when proxy is not available.<ul>
<li>Unregister service.</li>
<li>Wait that proxy is not available.</li>
<li>Test stub sets in-value of test methods.</li>
<li>Set timeout of asynchronous calls.</li>
<li>Make asynchronous call of test method.</li>
<li>Make asynchronous call of test method in callback (nested).</li>
<li>Do checks of call status (CommonAPI::CallStatus::NOT_AVAILABLE) and that timeouts occurred.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a15380a7c3fd6502f090e4a4b6ebccf7a">CMMethodCalls_NestedAsynchronousMethodCallsTimedOut</a>  ()</dt>
<dd><a class="anchor" id="_test000076"></a>Call test method timeout asynchronous and call test method timeout asynchronous in callback (nested).<ul>
<li>Register second service with other instance</li>
<li>Create second proxy to second service</li>
<li>Make asynchronous call of test method timeout (first proxy)</li>
<li>Make asynchronous call of test method timeout (second proxy)</li>
<li>Check in callbacks if timeout occured (CommonAPI::CallStatus::REMOTE_ERROR)</li>
<li>Make asynchronous calls of test method timeout in callbacks as long as timeoutCalls_ &lt; maxTimeoutCalls_ (nested).</li>
<li>Check if the same amount of timeouts occured as async calls were done  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#ac7e82226d8fb057fd04b3547ee11baec">CMMethodCalls_NestedSynchronousMethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000074"></a>Call test method asynchronous and call test method synchronous in callback (nested).<ul>
<li>Test stub sets in-values of test methods.</li>
<li>Make asynchronous call of test method.</li>
<li>Make asynchronous call of test method in callback (nested).</li>
<li>Do checks of call status (CommonAPI::CallStatus::SUCCESS) and stored values in callback functions.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="CMMethodCalls_8cpp.html#a03b877d8a608b78d912148ca6e54431c">CMMethodCalls_SynchronousMethodCall</a>  ()</dt>
<dd><a class="anchor" id="_test000071"></a>Call test method synchronous and check call status.<ul>
<li>Test stub sets in-value of test method equal out-value of test method.</li>
<li>Make synchronous call of test method.</li>
<li>Check if returned call status is CommonAPI::CallStatus::SUCCESS.</li>
<li>Check if out value of test method is equal to in value.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTAdvanced_8cpp.html#ac4373b38318b2eef977abcfe7e7646d5">DTAdvanced_AttributeSet</a>  ()</dt>
<dd><a class="anchor" id="_test000087"></a>Test attribute functions with advanced types<ul>
<li>Call set function of attributes with advanced types</li>
<li>Call get function and check if the return value is the same  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTAdvanced_8cpp.html#a866a1c00ca113c12488ea643ff116cf7">DTAdvanced_AttributeSetAsyncInvalid</a>  ()</dt>
<dd><a class="anchor" id="_test000086"></a>Test attribute asynchronous functions with invalid values<ul>
<li>Call set asynch function of attributes with invalid types</li>
<li>Callback should be called with error status</li>
<li>Check that attribute value has not changed  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTAdvanced_8cpp.html#ac2236f8cbb3e4dd724751fff2587f6d0">DTAdvanced_AttributeSetInvalid</a>  ()</dt>
<dd><a class="anchor" id="_test000084"></a>Test attribute functions with invalid values<ul>
<li>Call set function of attributes with invalid types</li>
<li>Check that the attribute's value has not changed  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTAdvanced_8cpp.html#adf3e5b881cbdca004a5489bd536ab165">DTAdvanced_BroadcastReceive</a>  ()</dt>
<dd><a class="anchor" id="_test000088"></a>Test broadcast with advanced types<ul>
<li>Subscribe to broadcast which contains advanced types</li>
<li>Call function to cause the stub to fire broadcast event with the same content</li>
<li>Check if the values in the callback function are as expected  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTAdvanced_8cpp.html#ac2fb626a7fa7ebba271564875798edfb">DTAdvanced_DISABLED_AttributeSetInvalidMapLength</a>  ()</dt>
<dd><a class="anchor" id="_test000085"></a>Test attribute functions with invalid map length<ul>
<li>Call set function of attributes with map length</li>
<li>Check that an error returns  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTCombined_8cpp.html#ab7a80fe32fafb788cef9ab9ba214efa8">DTCombined_CheckInitialValue</a>  ()</dt>
<dd><a class="anchor" id="_test000090"></a>Test that combined types are properly initialized  </dd>
<dt>Global <a class="el" href="DTCombined_8cpp.html#a68b6329ab36f57a29cc294503e9a4fa5">DTCombined_SendAndReceive</a>  ()</dt>
<dd><a class="anchor" id="_test000089"></a>Test function call with combined type<ul>
<li>The combined type is one structure with combinations of advanced and primitive types</li>
<li>Function call of a function that has for each advanced type one argument (test values) and one return value</li>
<li>The stub copies the test values to the return values</li>
<li>On client side the test values are compared with the return values  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTConstants_8cpp.html#a06f6eb34cf829c0f8f169c0f43b3baef">DTConstants_InterfaceConstants</a>  ()</dt>
<dd><a class="anchor" id="_test000091"></a>See that we can access constants in an interface and that they have correct values  </dd>
<dt>Global <a class="el" href="DTConstants_8cpp.html#ae1d93fc0ac523a26513b7e7253438fba">DTConstants_TypeCollectionConstants</a>  ()</dt>
<dd><a class="anchor" id="_test000092"></a>See that we can access constants in type collection and that they have correct values  </dd>
<dt>Global <a class="el" href="DTDeployment_8cpp.html#a925495ed19074210d3cf40c7e88f8e9e">DTDeployment_TryGetAttributeWithGetterIDSetToZeroInDeployment</a>  ()</dt>
<dd><a class="anchor" id="_test000094"></a>Test Try to get attribute deployed with GetterID=0<ul>
<li>Subscribe to changed event of attribute</li>
<li>Set value to attribute via stub</li>
<li>Make sure subscription handler was called</li>
<li>Set value to attribute via proxy</li>
<li>Make sure subscription handler was called</li>
<li>Check via stub that proxy set correct value</li>
<li>Try to get Attribute via proxy and make sure CallStatus::NOT_AVAILABLE is returned  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTDeployment_8cpp.html#a708d1059831f0dd8afcdb1be3691ca25">DTDeployment_TryGetNoSubsriptionAttributeWithGetterIDSetToZeroInDeployment</a>  ()</dt>
<dd><a class="anchor" id="_test000093"></a>Test Try to get noSubscription attribute deployed with GetterID=0 and NotifierID=0<ul>
<li>Set value to attribute via stub</li>
<li>Set value to attribute via proxy</li>
<li>Check via stub that proxy set correct value</li>
<li>Try to get Attribute via proxy and make sure CallStatus::NOT_AVAILABLE is returned  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTDerived_8cpp.html#a450e054d6d5a8578932541ada3b0a2b7">DTDerived_AttributeSet</a>  ()</dt>
<dd><a class="anchor" id="_test000095"></a>Test attribute functions with derived types<ul>
<li>Call set function of attributes with derived types</li>
<li>Call get function and check if the return value is the same  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTDerived_8cpp.html#a4ed7040492d65c3eb5f949c28b1da3ba">DTDerived_BroadcastReceive</a>  ()</dt>
<dd><a class="anchor" id="_test000096"></a>Test broadcast with derived types<ul>
<li>Subscribe to broadcast which contains derived types</li>
<li>Call function to cause the stub to fire broadcast event with the same content</li>
<li>Check if the values in the callback function are as expected  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTPrimitive_8cpp.html#a14844579f03beb9a8b38fdabcbaaef13">DTPrimitive_AttributeSet</a>  ()</dt>
<dd><a class="anchor" id="_test000098"></a>Test attribute functions with primitive types<ul>
<li>Call set function of attributes with primitive types</li>
<li>Call get function and check if the return value is the same  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTPrimitive_8cpp.html#ab2b30b1cfb20d1c294643c66c0a1109e">DTPrimitive_BroadcastReceive</a>  ()</dt>
<dd><a class="anchor" id="_test000099"></a>Test broadcast with primitive types<ul>
<li>Subscribe to broadcast which contains primitive types</li>
<li>Call function to cause the stub to fire broadcast event with the same content</li>
<li>Check if the values in the callback function are as expected  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTPrimitive_8cpp.html#a075114563b66ad83a62aa69317f254c3">DTPrimitive_EmptyBroadcastReceive</a>  ()</dt>
<dd><a class="anchor" id="_test000100"></a>Test broadcast with empty broadcast<ul>
<li>Subscribe to broadcast which does not contain any datatypes</li>
<li>Call function twice to cause the stub to fire a broadcast event</li>
<li>Check if the callback function was called twice  </li>
</ul>
</dd>
<dt>Global <a class="el" href="DTPrimitive_8cpp.html#ac0244469716e05a1dc62cc4ae09c0892">DTPrimitive_RangedIntegers</a>  ()</dt>
<dd><a class="anchor" id="_test000101"></a>Test ranged integer functionality  </dd>
<dt>Global <a class="el" href="DTPrimitive_8cpp.html#a2696d97d1e7f7b0f320325314c2c35c4">DTPrimitive_SendAndReceive</a>  ()</dt>
<dd><a class="anchor" id="_test000097"></a>Test function call with primitive types<ul>
<li>Primitive types are: uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, bool, float, double, std::string, ByteBuffer</li>
<li>Function call of a function that has for each primitive type one argument (test values) and one return value</li>
<li>The stub copies the test values to the return values</li>
<li>On client side the test values are compared with the return values  </li>
</ul>
</dd>
<dt>Global <a class="el" href="PFComplex_8cpp.html#a09ee9b55cc35a9ebb1a672087e95536a">PFComplex_Ping_Pong_Complex_Asynchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000103"></a>Test asynchronous ping pong function call<ul>
<li>complex array is array of a struct containing an union and another struc with primitive datatypes</li>
<li>The stub just set (copies) the in array to the out array</li>
<li>Only the CallStatus will be used to verify the async call has succeeded</li>
<li>Using double payload every cycle, starting with 1 end with maxPrimitiveArraySize</li>
<li>Doing loopCountPerPaylod loops to calc the mean time  </li>
</ul>
</dd>
<dt>Global <a class="el" href="PFComplex_8cpp.html#a84d84fb85a7b74a5ea5d319cbc20b36d">PFComplex_Ping_Pong_Complex_Synchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000102"></a>Test synchronous ping pong function call<ul>
<li>complex array is array of a struct containing an union and another struc with primitive datatypes</li>
<li>The stub just set the in array to the out array</li>
<li>CallStatus and array content will be used to verify the sync call has succeeded</li>
<li>Using double payload every cycle, starting with 1 end with maxPrimitiveArraySize</li>
<li>Doing primitiveLoopSize loops to build the mean time  </li>
</ul>
</dd>
<dt>Global <a class="el" href="PFPrimitive_8cpp.html#ab0575280181b87082b01390bcaa967bb">PFPrimitive_Ping_Pong_Primitive_Asynchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000105"></a>Test asynchronous ping pong function call<ul>
<li>primitive array is array of UInt_8<ul>
<li>The stub just set (copies) the in array to the out array</li>
<li>Only the CallStatus will be used to verify the async call has succeeded</li>
<li>Using double payload every cycle, starting with 1 end with maxPrimitiveArraySize</li>
<li>Doing primitiveLoopSize loops to build the mean time  </li>
</ul>
</li>
</ul>
</dd>
<dt>Global <a class="el" href="PFPrimitive_8cpp.html#a6664bb93ce61726f658c9582542b099b">PFPrimitive_Ping_Pong_Primitive_Synchronous</a>  ()</dt>
<dd><a class="anchor" id="_test000104"></a>Test synchronous ping pong function call<ul>
<li>primitive array is array of UInt_8<ul>
<li>The stub just set the in array to the out array</li>
<li>CallStatus and array content will be used to verify the sync call has succeeded</li>
<li>Using double payload every cycle, starting with 1 end with maxPrimitiveArraySize</li>
<li>Doing primitiveLoopSize loops to build the mean time  </li>
</ul>
</li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#a8fe93e71f2e8bef2709499b1551434b3">RTBuildProxiesAndStubs_BuildProxiesAndStubsTwoTimes</a>  ()</dt>
<dd><a class="anchor" id="_test000107"></a>Loads Runtime, creates proxy and stub/service two times.<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true</li>
<li>Create stub and register service</li>
<li>Create proxy</li>
<li>Do some synchronous calls</li>
<li>Unregister the service.</li>
<li>Create stub and register service</li>
<li>Create proxy</li>
<li>Checks whether proxy is available</li>
<li>Unregister the service  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#a11c6ee2283ecda29e762aa29c8086072">RTBuildProxiesAndStubs_BuildProxySubscribeToProxyStatusEventBlockingCallAndShutdown</a>  ()</dt>
<dd><a class="anchor" id="_test000112"></a>Loads Runtime, creates proxy, subscribes to proxy status event, does a blocking call and shutdown<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true.</li>
<li>Checks if test proxy with domain and test instance can be created.</li>
<li>Subscribes to proxy status event and simulate a blocking call (simulated by sleep) when proxy is getting available</li>
<li>Register the test service</li>
<li>Initiate shutdown when blocking call was done</li>
<li>Unregister test service</li>
<li>Wait till proxy is getting unavailable</li>
<li>Destroy proxy</li>
<li>Wait till proxy was destroyed and proxy status event handler is finished  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#a046802896a2c6eb6aa47450e1f4224b3">RTBuildProxiesAndStubs_BuildProxyTwoTimesWithReassigningAndStub</a>  ()</dt>
<dd><a class="anchor" id="_test000108"></a>Loads Runtime, creates proxy two times with reassigning and create stub/service.<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true</li>
<li>Create proxy</li>
<li>Create proxy again and reassign</li>
<li>Create stub and register service</li>
<li>Checks whether proxy is available</li>
<li>Do synchronous calls</li>
<li>Unregister the service.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#a99568879580b0e34ae670608c17fb07b">RTBuildProxiesAndStubs_LoadedRuntimeCanBuildProxiesAndStubs</a>  ()</dt>
<dd><a class="anchor" id="_test000106"></a>Loads Runtime, creates proxy and stub/service.<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true.</li>
<li>Checks if test proxy with domain and test instance can be created.</li>
<li>Checks if test stub can be created.</li>
<li>Register the test service.</li>
<li>Unregister the test service.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#acb958b070abb2ee9c91cd6e72ad53222">RTBuildProxiesAndStubs_WaitForProxyDestruction</a>  ()</dt>
<dd><a class="anchor" id="_test000109"></a>Loads Runtime, creates proxy and stub/service, await proxy destruction<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true.</li>
<li>Checks if test proxy with domain and test instance can be created</li>
<li>Checks if test stub can be created.</li>
<li>Register the test service.</li>
<li>Wait for service availability</li>
<li>Unregister the test service.</li>
<li>Wait for on future till proxy was destroyed after std::shared_ptr&lt;&gt; ref from thread was released  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#aa7a51dc8668c06d0622aa54b062efd75">RTBuildProxiesAndStubs_WaitForProxyDestructionCreatedInThread</a>  ()</dt>
<dd><a class="anchor" id="_test000110"></a>Loads Runtime, creates proxy and stub/service, await proxy destruction<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true.</li>
<li>Checks if test proxy with domain and test instance can be created (in an own thread).</li>
<li>Checks if test stub can be created.</li>
<li>Register the test service.</li>
<li>Wait for service availability on the test proxy in it's thread.</li>
<li>Unregister the test service.</li>
<li>Wait till proxy was destroyed when std::shared_ptr&lt;&gt; in thread has been released.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTBuildProxiesAndStubs_8cpp.html#a60b3f89eaa1edaafbe8e6cdfe9e1843c">RTBuildProxiesAndStubs_WaitForProxyDestructionInTwoThreads</a>  ()</dt>
<dd><a class="anchor" id="_test000111"></a>Loads Runtime, creates proxy and stub/service, await proxy destruction in two threads<ul>
<li>Calls CommonAPI::Runtime::get() and checks if return value is true.</li>
<li>Checks if test proxy with domain and test instance can be created (in an own thread).</li>
<li>Wait till proxy was destroyed when std::shared_ptr&lt;&gt; in threads</li>
<li>Join the threads that have been waiting for proxy destruction  </li>
</ul>
</dd>
<dt>Global <a class="el" href="RTLoadingRuntime_8cpp.html#a003ac0cadf3556e91196cd0e58b16df1">RTLoadingRuntime_LoadsDefaultRuntime</a>  ()</dt>
<dd><a class="anchor" id="_test000113"></a>Loads Default Runtime.<ul>
<li>Calls CommonAPI::Runtime::get().</li>
<li>Success if return value is true.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#a860c7db6cd34eae1f8a3b28eee16434f">StabilitySP_MultipleAttributeGetAsyncs</a>  ()</dt>
<dd><a class="anchor" id="_test000118"></a>Create a number of services and proxies and get attributes through them.<ul>
<li>Register MAXSERVERCOUNT addresses as services<ul>
<li>Set the attribute for service, at the stub side.</li>
</ul>
</li>
<li>Create MAXTHREADCOUNT threads, each of which creates a proxy for each service address and then gets attributes MAXMETHODCALLS times for each asynchronously</li>
<li>Each attribute is MESSAGESIZE bytes long.</li>
<li>Test fails if any of the services fail to get registered or if any of the proxies won't get available or if the callbacks are not called correct number of times  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#affe29204d724f25189eda5ec88a04bc4">StabilitySP_MultipleAttributeGets</a>  ()</dt>
<dd><a class="anchor" id="_test000117"></a>Create a number of services and proxies and get attributes through them.<ul>
<li>Register MAXSERVERCOUNT addresses as services<ul>
<li>Set the attribute for service, at the stub side.</li>
</ul>
</li>
<li>Create MAXTHREADCOUNT threads, each of which creates a proxy for each service address and then gets attributes MAXMETHODCALLS times for each.</li>
<li>Each attribute is MESSAGESIZE bytes long.</li>
<li>Test fails if any of the services fail to get registered or if any of the proxies won't get available or if the returned attribute from the server is not correct  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#a677f6b20d04c21896f93815db3a1f686">StabilitySP_MultipleAttributeSetAsyncs</a>  ()</dt>
<dd><a class="anchor" id="_test000119"></a>Create a number of services and proxies and set attributes through them.<ul>
<li>Register MAXSERVERCOUNT addresses as services<ul>
<li>Set the attribute for service, at the stub side.</li>
</ul>
</li>
<li>Create MAXTHREADCOUNT threads, each of which creates a proxy for each service address and then sets attributes MAXMETHODCALLS times for each asynchronously</li>
<li>Each attribute is MESSAGESIZE bytes long.</li>
<li>Test fails if any of the services fail to get registered or if any of the proxies won't get available or if the callbacks are not called correct number of times  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#aebc86a3044701a645e1c4665699771a8">StabilitySP_MultipleAttributeSets</a>  ()</dt>
<dd><a class="anchor" id="_test000116"></a>Create a number of services and proxies and set attributes through them.<ul>
<li>Register MAXSERVERCOUNT addresses as services</li>
<li>Create MAXTHREADCOUNT threads, each of which creates a proxy for each service address and then sets attributes MAXMETHODCALLS times to each.</li>
<li>Each attribute is MESSAGESIZE bytes long.</li>
<li>Test fails if any of the services fail to get registered or if any of the proxies won't get available or if the return attribute from the server is not correct  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#a57577e934f093a36ef7b004a59b56b05">StabilitySP_MultipleAttributeSubscriptions</a>  ()</dt>
<dd><a class="anchor" id="_test000120"></a>Create a number of services and proxies and set attributes through them.<ul>
<li>Register MAXSERVERCOUNT addresses as services<ul>
<li>Set the attribute for service, at the stub side.</li>
</ul>
</li>
<li>Create MAXTHREADCOUNT threads, each of which creates a proxy for each service address and then sets attributes MAXMETHODCALLS times for each asynchronously</li>
<li>Each attribute is MESSAGESIZE bytes long.</li>
<li>Test fails if any of the services fail to get registered or if any of the proxies won't get available or if the callbacks are not called correct number of times  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#a6ec48a3714358d1421caa45ee04b72ca">StabilitySP_MultipleMethodCalls</a>  ()</dt>
<dd><a class="anchor" id="_test000115"></a>Create a number of services and proxies and send messages through them.<ul>
<li>Register MAXSERVERCOUNT addresses as services</li>
<li>Create MAXTHREADCOUNT threads, each of which creates a proxy for each service address and then sends MAXMETHODCALLS messages to each.</li>
<li>Each message is MESSAGESIZE bytes long.</li>
<li>Test fails if any of the services fail to get registered or if any of the proxies won't get available or if the return message from the server is not correct  </li>
</ul>
</dd>
<dt>Global <a class="el" href="StabilitySP_8cpp.html#a5e07bc3a1b188b54070ae4d7e778f5f3">StabilitySP_RepeatedRegistrations</a>  ()</dt>
<dd><a class="anchor" id="_test000114"></a>Register and unregister services in a loop.<ul>
<li>do MAXREGLOOPS times:</li>
<li>register MAXREGCOUNT addresses as services</li>
<li>unregister the addresses that were just registered</li>
<li>check the return code of each register/unregister call</li>
<li>test fails if any of the return codes are false  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIndependence_8cpp.html#a4fcb2f60c64e5906b4e8117d4c44c954">THMainLoopIndependence_ProxyReceivesAnswerOnlyIfStubMainLoopRuns</a>  ()</dt>
<dd><a class="anchor" id="_test000121"></a>Proxy Receives Answer Only If Stub MainLoop Runs.<ul>
<li>start proxy in thread 1 and call testPredefinedTypeMethod</li>
<li>proxy should not receive answer, if the stub mainloop does not run</li>
<li>run mainloop of stub</li>
<li>now the stub mainloop also runs, so the proxy should receive the answer  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIndependence_8cpp.html#af8f4622fa684abedb3b852c4db5bfe93">THMainLoopIndependence_ProxyReceivesJustHisOwnAnswersAsync</a>  ()</dt>
<dd><a class="anchor" id="_test000123"></a>Proxy Receives Just His Own Answers.<ul>
<li>start 2 proxies in own threads</li>
<li>call test method in each proxy asynchronously</li>
<li>now each proxy should have received the answer to his own request  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIndependence_8cpp.html#ae574ba08b69e2e47257517b8240fdca2">THMainLoopIndependence_ProxyReceivesJustHisOwnAnswersSync</a>  ()</dt>
<dd><a class="anchor" id="_test000122"></a>Proxy Receives Just His Own Answers.<ul>
<li>start 2 proxies in own threads</li>
<li>call test method in each proxy synchronously</li>
<li>now each proxy should have received the answer to his own request  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIntegration_8cpp.html#a60b7434ec7c964db5bf630e0f2c36d82">THMainLoopIntegration_AsynchronousMethodCallsReceiveNotAvailable</a>  ()</dt>
<dd><a class="anchor" id="_test000128"></a>Call test method multiple times asynchronously while the service is unavailable and check if the provided callback is called with an error for every method call done.  </dd>
<dt>Global <a class="el" href="THMainLoopIntegration_8cpp.html#ac851a9bde7cd84c485bb42c94f54f95d">THMainLoopIntegration_CreateProxyToManagerInSameProcess</a>  ()</dt>
<dd><a class="anchor" id="_test000129"></a>Offer a interface manager and build two proxies to it. One proxy uses the same connection as the manager while the other uses a different connection. Check that both proxies get available and receive a available event  </dd>
<dt>Global <a class="el" href="THMainLoopIntegration_8cpp.html#aa41dcc65d36885ecf26d73d43b0bbb14">THMainLoopIntegration_SelectiveErrorHandlerWithMainLoop</a>  ()</dt>
<dd><a class="anchor" id="_test000127"></a>Verifies SelectiveError Handler is called correctly when used with mainloop<ul>
<li>get proxy with available flag = true</li>
<li>Subscribe for selective Event and register error handler</li>
<li>Stub fires event upon subscription</li>
<li>Check that subscription handler and error handler were both called once</li>
<li>Unregister Service and register Service again</li>
<li>Check that subscription error handler was called again after service went offline and came online again (resubscription took place) and that the event was received a second time  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIntegration_8cpp.html#a2ac3fdc64e05d2bf32abf3a7b76732fb">THMainLoopIntegration_VerifyCommunicationWithMainLoop</a>  ()</dt>
<dd><a class="anchor" id="_test000124"></a>Verifies communication with Main Loop.<ul>
<li>get proxy with available flag = true</li>
<li>generate big test data</li>
<li>send synchronous test message  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIntegration_8cpp.html#ad7e3e2d98dd7eb56473cf0fdf2aa5712">THMainLoopIntegration_VerifySyncCallMessageHandlingOrder</a>  ()</dt>
<dd><a class="anchor" id="_test000126"></a>Verifies Synchronous Call Message Handling Order.<ul>
<li>get proxy with available flag = true</li>
<li>subscribe for broadcast event</li>
<li>generate 5 test broadcasts</li>
<li>5 broadcasts should arrive in the right order  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopIntegration_8cpp.html#a98f1abb1a604f92163daeb8e48e075e8">THMainLoopIntegration_VerifyTransportReading</a>  ()</dt>
<dd><a class="anchor" id="_test000125"></a>Verifies Transport Reading When Dispatching Watches.<ul>
<li>get proxy with available flag = true</li>
<li>generate big test data</li>
<li>send asynchronous test message</li>
<li>dispatch dispatchSource: the message must not be arrived</li>
<li>dispatch watches (reads transport).</li>
<li>dispatch dispatchSources again: now the message must be arrived.  </li>
</ul>
</dd>
<dt>Global <a class="el" href="THMainLoopTwoThreads_8cpp.html#a026d4c81545d9374790eb2bdd7ec149e">THMainLoopTwoThreads_ProxyGetsAvailableStatus</a>  ()</dt>
<dd><a class="anchor" id="_test000130"></a>Proxy Receives Available when MainLoop Dispatched sourced out to other thread.  </dd>
<dt>Global <a class="el" href="THMainLoopTwoThreads_8cpp.html#a61bfe1b357cb6e5b31a90837d81d7c7c">THMainLoopTwoThreads_ProxyGetsFunctionResponse</a>  ()</dt>
<dd><a class="anchor" id="_test000131"></a>Proxy gets function response when MainLoop Dispatched sourced out to other thread. </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 13 2022 14:24:25 for CommonAPITests by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
